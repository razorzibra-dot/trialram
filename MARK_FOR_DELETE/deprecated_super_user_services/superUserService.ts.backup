/**
 * Super User Module - Mock Service Implementation
 * 
 * This service provides mock data and operations for the Super User module.
 * Used during development and testing when VITE_API_MODE=mock.
 * 
 * CRITICAL: All methods MUST match the same signatures and validation logic
 * as the Supabase service (src/services/api/supabase/superUserService.ts)
 * 
 * Layer Sync Rule:
 * - Database: snake_case columns (SQL)
 * - This file: camelCase fields (TypeScript)
 * - Return types MUST exactly match TypeScript interfaces
 * - Validation MUST be identical to Supabase service
 * 
 * Last Updated: 2025-02-11
 */

import {
    SuperUserTenantAccessType,
    ImpersonationLogType,
    TenantStatisticType,
    TenantConfigOverrideType,
    SuperUserTenantAccessCreateInput,
    SuperUserTenantAccessUpdateInput,
    ImpersonationStartInput,
    ImpersonationEndInput,
    TenantStatisticCreateInput,
    TenantConfigOverrideCreateInput,
    TenantConfigOverrideUpdateInput,
    validateSuperUserTenantAccessCreate,
    validateImpersonationStart,
    validateImpersonationEnd,
    validateTenantStatisticCreate,
    validateTenantConfigOverrideCreate,
    validateTenantConfigOverrideUpdate,
} from '@/types/superUserModule';

/**
 * =====================================================
 * MOCK DATA - Simulates Database Records
 * =====================================================
 */

const mockSuperUserTenantAccess: SuperUserTenantAccessType[] = [
    {
        id: '550e8400-e29b-41d4-a716-446655440001',
        superUserId: 'user-001',
        tenantId: 'tenant-001',
        accessLevel: 'full',
        createdAt: '2025-01-15T10:00:00Z',
        updatedAt: '2025-01-15T10:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655440002',
        superUserId: 'user-001',
        tenantId: 'tenant-002',
        accessLevel: 'limited',
        createdAt: '2025-01-15T10:05:00Z',
        updatedAt: '2025-01-15T10:05:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655440003',
        superUserId: 'user-002',
        tenantId: 'tenant-001',
        accessLevel: 'read_only',
        createdAt: '2025-01-15T10:10:00Z',
        updatedAt: '2025-01-15T10:10:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655440004',
        superUserId: 'user-002',
        tenantId: 'tenant-002',
        accessLevel: 'limited',
        createdAt: '2025-01-15T10:15:00Z',
        updatedAt: '2025-01-15T10:15:00Z',
    },
];

const mockImpersonationLogs: ImpersonationLogType[] = [
    {
        id: '550e8400-e29b-41d4-a716-446655450001',
        superUserId: 'user-001',
        impersonatedUserId: 'user-100',
        tenantId: 'tenant-001',
        reason: 'Troubleshooting customer issue',
        loginAt: '2025-02-10T14:00:00Z',
        logoutAt: '2025-02-10T14:30:00Z',
        actionsTaken: [
            { action: 'viewed_contracts', count: 5 },
            { action: 'exported_report', timestamp: '2025-02-10T14:25:00Z' },
        ],
        ipAddress: '192.168.1.100',
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        createdAt: '2025-02-10T14:00:00Z',
        updatedAt: '2025-02-10T14:30:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655450002',
        superUserId: 'user-002',
        impersonatedUserId: 'user-101',
        tenantId: 'tenant-002',
        reason: 'Testing new feature',
        loginAt: '2025-02-09T09:00:00Z',
        logoutAt: '2025-02-09T09:45:00Z',
        actionsTaken: [
            { action: 'created_draft_contract', id: 'draft-001' },
        ],
        ipAddress: '192.168.1.101',
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
        createdAt: '2025-02-09T09:00:00Z',
        updatedAt: '2025-02-09T09:45:00Z',
    },
];

const mockTenantStatistics: TenantStatisticType[] = [
    {
        id: '550e8400-e29b-41d4-a716-446655460001',
        tenantId: 'tenant-001',
        metricType: 'active_users',
        metricValue: 150,
        recordedAt: '2025-02-11T00:00:00Z',
        updatedAt: '2025-02-11T00:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655460002',
        tenantId: 'tenant-001',
        metricType: 'total_contracts',
        metricValue: 342,
        recordedAt: '2025-02-11T00:00:00Z',
        updatedAt: '2025-02-11T00:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655460003',
        tenantId: 'tenant-001',
        metricType: 'total_sales',
        metricValue: 125000.50,
        recordedAt: '2025-02-11T00:00:00Z',
        updatedAt: '2025-02-11T00:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655460004',
        tenantId: 'tenant-002',
        metricType: 'active_users',
        metricValue: 75,
        recordedAt: '2025-02-11T00:00:00Z',
        updatedAt: '2025-02-11T00:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655460005',
        tenantId: 'tenant-002',
        metricType: 'total_contracts',
        metricValue: 156,
        recordedAt: '2025-02-11T00:00:00Z',
        updatedAt: '2025-02-11T00:00:00Z',
    },
];

const mockTenantConfigOverrides: TenantConfigOverrideType[] = [
    {
        id: '550e8400-e29b-41d4-a716-446655470001',
        tenantId: 'tenant-001',
        configKey: 'email_notification_enabled',
        configValue: { enabled: false, reason: 'Temporary maintenance' },
        overrideReason: 'System maintenance period',
        createdBy: 'user-001',
        createdAt: '2025-02-10T08:00:00Z',
        expiresAt: '2025-02-12T08:00:00Z',
        updatedAt: '2025-02-10T08:00:00Z',
    },
    {
        id: '550e8400-e29b-41d4-a716-446655470002',
        tenantId: 'tenant-001',
        configKey: 'max_contract_value',
        configValue: { limit: 500000, currency: 'USD' },
        overrideReason: 'Special arrangement for large deal',
        createdBy: 'user-001',
        createdAt: '2025-02-01T10:00:00Z',
        expiresAt: undefined,
        updatedAt: '2025-02-01T10:00:00Z',
    },
];

/**
 * =====================================================
 * MOCK SERVICE - All Methods
 * =====================================================
 */

export const mockSuperUserService = {
    /**
     * ===== TENANT ACCESS MANAGEMENT =====
     */

    /**
     * Get all super user tenant access records
     * @returns Array of tenant access records
     * @throws Error if fetch fails
     */
    async getSuperUserTenantAccess(): Promise<SuperUserTenantAccessType[]> {
        try {
            // Simulate network delay
            await new Promise((resolve) => setTimeout(resolve, 100));
            return [...mockSuperUserTenantAccess];
        } catch (error) {
            throw new Error(`Failed to fetch super user tenant access: ${error}`);
        }
    },

    /**
     * Get tenant access for a specific super user
     * @param superUserId - Super user ID
     * @returns Array of tenant access records for this super user
     * @throws Error if not found
     */
    async getTenantAccessByUserId(
        superUserId: string
    ): Promise<SuperUserTenantAccessType[]> {
        try {
            if (!superUserId) {
                throw new Error('Super user ID is required');
            }
            const access = mockSuperUserTenantAccess.filter(
                (a) => a.superUserId === superUserId
            );
            return [...access];
        } catch (error) {
            throw new Error(`Failed to fetch tenant access for user ${superUserId}: ${error}`);
        }
    },

    /**
     * Get a specific tenant access record
     * @param id - Tenant access ID
     * @returns Tenant access record
     * @throws Error if not found
     */
    async getSuperUserTenantAccessById(id: string): Promise<SuperUserTenantAccessType> {
        try {
            if (!id) {
                throw new Error('Access ID is required');
            }
            const access = mockSuperUserTenantAccess.find((a) => a.id === id);
            if (!access) {
                throw new Error(`Tenant access ${id} not found`);
            }
            return { ...access };
        } catch (error) {
            throw new Error(`Failed to fetch tenant access: ${error}`);
        }
    },

    /**
     * Grant a super user access to a tenant
     * @param input - Create input
     * @returns Created tenant access record
     * @throws Error if validation fails or duplicate exists
     */
    async grantTenantAccess(
        input: SuperUserTenantAccessCreateInput
    ): Promise<SuperUserTenantAccessType> {
        try {
            // Validate input
            validateSuperUserTenantAccessCreate(input);

            // Check for duplicate
            const exists = mockSuperUserTenantAccess.some(
                (a) => a.superUserId === input.superUserId && a.tenantId === input.tenantId
            );
            if (exists) {
                throw new Error(
                    `Super user ${input.superUserId} already has access to tenant ${input.tenantId}`
                );
            }

            const newAccess: SuperUserTenantAccessType = {
                id: `access-${Date.now()}`,
                superUserId: input.superUserId,
                tenantId: input.tenantId,
                accessLevel: input.accessLevel || 'limited',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };

            mockSuperUserTenantAccess.push(newAccess);
            return { ...newAccess };
        } catch (error) {
            throw new Error(`Failed to grant tenant access: ${error}`);
        }
    },

    /**
     * Update tenant access level
     * @param id - Access ID
     * @param input - Update input
     * @returns Updated tenant access record
     * @throws Error if not found or validation fails
     */
    async updateTenantAccessLevel(
        id: string,
        input: SuperUserTenantAccessUpdateInput
    ): Promise<SuperUserTenantAccessType> {
        try {
            if (!id) {
                throw new Error('Access ID is required');
            }
            if (!input.accessLevel) {
                throw new Error('Access level is required');
            }

            const index = mockSuperUserTenantAccess.findIndex((a) => a.id === id);
            if (index === -1) {
                throw new Error(`Tenant access ${id} not found`);
            }

            mockSuperUserTenantAccess[index] = {
                ...mockSuperUserTenantAccess[index],
                accessLevel: input.accessLevel,
                updatedAt: new Date().toISOString(),
            };

            return { ...mockSuperUserTenantAccess[index] };
        } catch (error) {
            throw new Error(`Failed to update tenant access: ${error}`);
        }
    },

    /**
     * Revoke super user access to a tenant
     * @param superUserId - Super user ID
     * @param tenantId - Tenant ID
     * @throws Error if not found
     */
    async revokeTenantAccess(superUserId: string, tenantId: string): Promise<void> {
        try {
            if (!superUserId || !tenantId) {
                throw new Error('Super user ID and tenant ID are required');
            }

            const index = mockSuperUserTenantAccess.findIndex(
                (a) => a.superUserId === superUserId && a.tenantId === tenantId
            );
            if (index === -1) {
                throw new Error(
                    `Tenant access not found for user ${superUserId} and tenant ${tenantId}`
                );
            }

            mockSuperUserTenantAccess.splice(index, 1);
        } catch (error) {
            throw new Error(`Failed to revoke tenant access: ${error}`);
        }
    },

    /**
     * ===== IMPERSONATION MANAGEMENT =====
     */

    /**
     * Get all impersonation logs
     * @returns Array of impersonation logs
     */
    async getImpersonationLogs(): Promise<ImpersonationLogType[]> {
        try {
            await new Promise((resolve) => setTimeout(resolve, 100));
            return [...mockImpersonationLogs];
        } catch (error) {
            throw new Error(`Failed to fetch impersonation logs: ${error}`);
        }
    },

    /**
     * Get impersonation logs for a specific super user
     * @param superUserId - Super user ID
     * @returns Array of impersonation logs for this user
     */
    async getImpersonationLogsByUserId(superUserId: string): Promise<ImpersonationLogType[]> {
        try {
            if (!superUserId) {
                throw new Error('Super user ID is required');
            }
            const logs = mockImpersonationLogs.filter((l) => l.superUserId === superUserId);
            return [...logs];
        } catch (error) {
            throw new Error(`Failed to fetch impersonation logs for user ${superUserId}: ${error}`);
        }
    },

    /**
     * Get a specific impersonation log
     * @param id - Log ID
     * @returns Impersonation log record
     */
    async getImpersonationLogById(id: string): Promise<ImpersonationLogType> {
        try {
            if (!id) {
                throw new Error('Log ID is required');
            }
            const log = mockImpersonationLogs.find((l) => l.id === id);
            if (!log) {
                throw new Error(`Impersonation log ${id} not found`);
            }
            return { ...log };
        } catch (error) {
            throw new Error(`Failed to fetch impersonation log: ${error}`);
        }
    },

    /**
     * Start an impersonation session
     * @param input - Start input
     * @returns Created impersonation log
     */
    async startImpersonation(input: ImpersonationStartInput): Promise<ImpersonationLogType> {
        try {
            validateImpersonationStart(input);

            const newLog: ImpersonationLogType = {
                id: `impersonation-${Date.now()}`,
                superUserId: '', // Would be set from auth in real implementation
                impersonatedUserId: input.impersonatedUserId,
                tenantId: input.tenantId,
                reason: input.reason,
                loginAt: new Date().toISOString(),
                actionsTaken: [],
                ipAddress: input.ipAddress,
                userAgent: input.userAgent,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };

            mockImpersonationLogs.push(newLog);
            return { ...newLog };
        } catch (error) {
            throw new Error(`Failed to start impersonation: ${error}`);
        }
    },

    /**
     * End an impersonation session
     * @param logId - Log ID to end
     * @param actionsTaken - Actions captured
     * @returns Updated impersonation log
     */
    async endImpersonation(
        logId: string,
        actionsTaken?: Record<string, unknown>[]
    ): Promise<ImpersonationLogType> {
        try {
            if (!logId) {
                throw new Error('Log ID is required');
            }

            const index = mockImpersonationLogs.findIndex((l) => l.id === logId);
            if (index === -1) {
                throw new Error(`Impersonation log ${logId} not found`);
            }

            mockImpersonationLogs[index] = {
                ...mockImpersonationLogs[index],
                logoutAt: new Date().toISOString(),
                actionsTaken: actionsTaken || [],
                updatedAt: new Date().toISOString(),
            };

            return { ...mockImpersonationLogs[index] };
        } catch (error) {
            throw new Error(`Failed to end impersonation: ${error}`);
        }
    },

    /**
     * Get currently active impersonation sessions
     * @returns Array of active impersonation logs (with no logout_at)
     */
    async getActiveImpersonations(): Promise<ImpersonationLogType[]> {
        try {
            const active = mockImpersonationLogs.filter((l) => !l.logoutAt);
            return [...active];
        } catch (error) {
            throw new Error(`Failed to fetch active impersonations: ${error}`);
        }
    },

    /**
     * ===== TENANT STATISTICS MANAGEMENT =====
     */

    /**
     * Get all tenant statistics
     * @returns Array of tenant statistics
     */
    async getTenantStatistics(): Promise<TenantStatisticType[]> {
        try {
            await new Promise((resolve) => setTimeout(resolve, 100));
            return [...mockTenantStatistics];
        } catch (error) {
            throw new Error(`Failed to fetch tenant statistics: ${error}`);
        }
    },

    /**
     * Get statistics for a specific tenant
     * @param tenantId - Tenant ID
     * @returns Array of statistics for this tenant
     */
    async getTenantStatisticsByTenantId(tenantId: string): Promise<TenantStatisticType[]> {
        try {
            if (!tenantId) {
                throw new Error('Tenant ID is required');
            }
            const stats = mockTenantStatistics.filter((s) => s.tenantId === tenantId);
            return [...stats];
        } catch (error) {
            throw new Error(`Failed to fetch tenant statistics for tenant ${tenantId}: ${error}`);
        }
    },

    /**
     * Record a new tenant metric
     * @param input - Create input
     * @returns Created statistic record
     */
    async recordTenantMetric(input: TenantStatisticCreateInput): Promise<TenantStatisticType> {
        try {
            validateTenantStatisticCreate(input);

            const newStat: TenantStatisticType = {
                id: `stat-${Date.now()}`,
                tenantId: input.tenantId,
                metricType: input.metricType,
                metricValue: input.metricValue,
                recordedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };

            mockTenantStatistics.push(newStat);
            return { ...newStat };
        } catch (error) {
            throw new Error(`Failed to record tenant metric: ${error}`);
        }
    },

    /**
     * ===== CONFIGURATION OVERRIDES MANAGEMENT =====
     */

    /**
     * Get all configuration overrides
     * @returns Array of configuration overrides
     */
    async getTenantConfigOverrides(): Promise<TenantConfigOverrideType[]> {
        try {
            await new Promise((resolve) => setTimeout(resolve, 100));
            return [...mockTenantConfigOverrides];
        } catch (error) {
            throw new Error(`Failed to fetch tenant config overrides: ${error}`);
        }
    },

    /**
     * Get configuration overrides for a specific tenant
     * @param tenantId - Tenant ID
     * @returns Array of overrides for this tenant
     */
    async getTenantConfigOverridesByTenantId(
        tenantId: string
    ): Promise<TenantConfigOverrideType[]> {
        try {
            if (!tenantId) {
                throw new Error('Tenant ID is required');
            }
            const overrides = mockTenantConfigOverrides.filter((o) => o.tenantId === tenantId);
            return [...overrides];
        } catch (error) {
            throw new Error(
                `Failed to fetch config overrides for tenant ${tenantId}: ${error}`
            );
        }
    },

    /**
     * Get a specific configuration override
     * @param id - Override ID
     * @returns Configuration override record
     */
    async getTenantConfigOverrideById(id: string): Promise<TenantConfigOverrideType> {
        try {
            if (!id) {
                throw new Error('Override ID is required');
            }
            const override = mockTenantConfigOverrides.find((o) => o.id === id);
            if (!override) {
                throw new Error(`Config override ${id} not found`);
            }
            return { ...override };
        } catch (error) {
            throw new Error(`Failed to fetch config override: ${error}`);
        }
    },

    /**
     * Create a configuration override
     * @param input - Create input
     * @returns Created override record
     */
    async createTenantConfigOverride(
        input: TenantConfigOverrideCreateInput
    ): Promise<TenantConfigOverrideType> {
        try {
            validateTenantConfigOverrideCreate(input);

            // Check for duplicate
            const exists = mockTenantConfigOverrides.some(
                (o) => o.tenantId === input.tenantId && o.configKey === input.configKey
            );
            if (exists) {
                throw new Error(
                    `Config override for key "${input.configKey}" already exists for tenant ${input.tenantId}`
                );
            }

            const newOverride: TenantConfigOverrideType = {
                id: `override-${Date.now()}`,
                tenantId: input.tenantId,
                configKey: input.configKey,
                configValue: input.configValue,
                overrideReason: input.overrideReason,
                createdBy: '', // Would be set from auth in real implementation
                createdAt: new Date().toISOString(),
                expiresAt: input.expiresAt,
                updatedAt: new Date().toISOString(),
            };

            mockTenantConfigOverrides.push(newOverride);
            return { ...newOverride };
        } catch (error) {
            throw new Error(`Failed to create config override: ${error}`);
        }
    },

    /**
     * Update a configuration override
     * @param id - Override ID
     * @param input - Update input
     * @returns Updated override record
     */
    async updateTenantConfigOverride(
        id: string,
        input: TenantConfigOverrideUpdateInput
    ): Promise<TenantConfigOverrideType> {
        try {
            if (!id) {
                throw new Error('Override ID is required');
            }

            validateTenantConfigOverrideUpdate(input);

            const index = mockTenantConfigOverrides.findIndex((o) => o.id === id);
            if (index === -1) {
                throw new Error(`Config override ${id} not found`);
            }

            mockTenantConfigOverrides[index] = {
                ...mockTenantConfigOverrides[index],
                ...input,
                updatedAt: new Date().toISOString(),
            };

            return { ...mockTenantConfigOverrides[index] };
        } catch (error) {
            throw new Error(`Failed to update config override: ${error}`);
        }
    },

    /**
     * Delete a configuration override
     * @param id - Override ID
     */
    async deleteTenantConfigOverride(id: string): Promise<void> {
        try {
            if (!id) {
                throw new Error('Override ID is required');
            }

            const index = mockTenantConfigOverrides.findIndex((o) => o.id === id);
            if (index === -1) {
                throw new Error(`Config override ${id} not found`);
            }

            mockTenantConfigOverrides.splice(index, 1);
        } catch (error) {
            throw new Error(`Failed to delete config override: ${error}`);
        }
    },
};

export default mockSuperUserService;