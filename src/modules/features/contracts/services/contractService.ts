/**
 * Contract Service (Module-level)
 * Business logic for contract management operations
 *
 * ARCHITECTURE:
 * This service delegates all core operations to the Service Factory pattern,
 * which provides automatic switching between mock (development) and Supabase
 * (production) backends based on VITE_API_MODE environment variable.
 *
 * MULTI-BACKEND ROUTING:
 * - VITE_API_MODE=mock    → Mock service (src/services/contractService.ts)
 * - VITE_API_MODE=supabase → Supabase service (src/services/supabase/contractService.ts)
 *
 * This ensures:
 * ✅ Single backend routing point via serviceFactory
 * ✅ Proper multi-tenant context maintained throughout stack
 * ✅ Eliminates "Unauthorized" errors from mixed backend imports
 * ✅ All module services follow consistent pattern
 *
 * @see /src/services/serviceFactory.ts - Central router for backend switching
 * @see /src/modules/features/tickets/services/ticketService.ts - Reference implementation
 */

import { BaseService } from '@/modules/core/services/BaseService';
import { Contract, ContractFormData, ContractFilters } from '@/types/contracts';
import { PaginatedResponse } from '@/modules/core/types';
import { contractService as factoryContractService } from '@/services/serviceFactory';

export interface ContractStats {
  total: number;
  active: number;
  pending_approval: number;
  expired: number;
  terminated: number;
  draft: number;
  renewed: number;
  totalValue: number;
  averageValue: number;
  expiringSoon: number;
  byType: Record<string, number>;
  byStatus: Record<string, number>;
  byPriority: Record<string, number>;
}

export interface ContractValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface ContractLifecycleEvent {
  id: string;
  contractId: string;
  eventType: 'created' | 'approved' | 'activated' | 'renewed' | 'expired' | 'terminated';
  timestamp: string;
  userId: string;
  notes?: string;
  metadata?: Record<string, any>;
}

export interface ContractAnalyticsData {
  contractId: string;
  metrics: {
    duration: number;
    valueUtilization: number;
    renewalRate: number;
    complianceScore: number;
  };
  trends: {
    value: number[];
    duration: number[];
    dates: string[];
  };
}

export class ContractService extends BaseService {
  /**
   * Get contracts with filtering and pagination
   * Delegates to factory-routed backend service
   */
  async getContracts(filters: ContractFilters = {}): Promise<PaginatedResponse<Contract>> {
    try {
      // Convert ContractFilters to the format expected by factory service
      const factoryFilters = {
        ...filters,
        page: (filters as any).page || 1,
        pageSize: (filters as any).pageSize || 20,
      };
      return await factoryContractService.getContracts(factoryFilters);
    } catch (error) {
      this.handleError('Failed to fetch contracts', error);
      throw error;
    }
  }

  /**
   * Get a single contract by ID
   * Delegates to factory-routed backend service
   */
  async getContract(id: string): Promise<Contract> {
    try {
      return await factoryContractService.getContract(id);
    } catch (error) {
      this.handleError(`Failed to fetch contract ${id}`, error);
      throw error;
    }
  }

  /**
   * Create a new contract
   * Delegates to factory-routed backend service
   */
  async createContract(data: ContractFormData): Promise<Contract> {
    try {
      // Convert ContractFormData to Partial<Contract> for factory service
      const factoryData: Partial<Contract> = {
        title: data.title,
        description: data.description,
        type: data.type,
        customer_id: data.customer_id,
        deal_id: data.deal_id,
        value: data.value,
        currency: data.currency,
        start_date: data.start_date,
        end_date: data.end_date,
        auto_renew: data.auto_renew,
        renewal_terms: data.renewal_terms,
        payment_terms: data.payment_terms,
        delivery_terms: data.delivery_terms,
        assigned_to: data.assigned_to,
        priority: data.priority,
        tags: data.tags,
        parties: data.parties.map(party => ({
          ...party,
          id: '', // Will be generated by backend
        })),
        status: 'draft',
        approval_history: [],
        signature_status: { total_required: data.parties.filter(p => p.signature_required).length, completed: 0, pending: [] },
        attachments: [],
        reminder_days: data.reminder_days,
        compliance_status: 'pending_review',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      return await factoryContractService.createContract(factoryData);
    } catch (error) {
      this.handleError('Failed to create contract', error);
      throw error;
    }
  }

  /**
   * Update an existing contract
   * Includes validation and business rules
   */
  async updateContract(id: string, data: Partial<ContractFormData>): Promise<Contract> {
    try {
      // Get current contract for validation
      const currentContract = await this.getContract(id);

      // Validate update data
      const validation = await this.validateContractUpdate(currentContract, data);
      if (!validation.isValid) {
        throw new Error(`Contract update validation failed: ${validation.errors.join(', ')}`);
      }

      // Prepare update data
      const updateData = this.prepareContractUpdateData(data);

      // Convert to Partial<Contract> for factory service
      const factoryData: Partial<Contract> = {
        ...updateData,
        parties: updateData.parties?.map(party => ({
          ...party,
          id: party.id || '',
          signed_at: party.signed_at,
          signature_url: party.signature_url,
        })),
      };

      // Update contract via factory service
      const updatedContract = await factoryContractService.updateContract(id, factoryData);

      return updatedContract;
    } catch (error) {
      this.handleError(`Failed to update contract ${id}`, error);
      throw error;
    }
  }

  /**
   * Delete a contract
   * Includes business rules (e.g., cannot delete active contracts)
   */
  async deleteContract(id: string): Promise<void> {
    try {
      const contract = await this.getContract(id);

      // Business rule: cannot delete active contracts
      if (contract.status === 'active') {
        throw new Error('Cannot delete an active contract. Terminate it first.');
      }

      // Business rule: cannot delete contracts with pending approvals
      if (contract.status === 'pending_approval') {
        throw new Error('Cannot delete a contract pending approval.');
      }

      await factoryContractService.deleteContract(id);

      // Log lifecycle event
      await this.logLifecycleEvent(id, 'terminated', 'Contract deleted');
    } catch (error) {
      this.handleError(`Failed to delete contract ${id}`, error);
      throw error;
    }
  }

  /**
   * Get contracts by customer ID
   */
  async getContractsByCustomer(customerId: string, filters: ContractFilters = {}): Promise<PaginatedResponse<Contract>> {
    try {
      return await factoryContractService.getContractsByCustomer(customerId, filters);
    } catch (error) {
      this.handleError(`Failed to fetch contracts for customer ${customerId}`, error);
      throw error;
    }
  }

  /**
   * Get contract statistics
   * Enhanced with business logic and analytics
   */
  async getContractStats(): Promise<ContractStats> {
    try {
      const stats = await factoryContractService.getContractStats();

      // Enhance with additional business metrics
      const contracts = await this.getContracts({ pageSize: 1000 });
      const enhancedStats = this.calculateEnhancedStats(contracts.data);

      return {
        ...stats,
        ...enhancedStats,
      };
    } catch (error) {
      this.handleError('Failed to fetch contract statistics', error);
      throw error;
    }
  }

  /**
   * Get expiring contracts
   */
  async getExpiringContracts(days: number = 30): Promise<PaginatedResponse<Contract>> {
    try {
      return await factoryContractService.getExpiringContracts(days);
    } catch (error) {
      this.handleError('Failed to fetch expiring contracts', error);
      throw error;
    }
  }

  /**
   * Get contracts due for renewal
   */
  async getContractsDueForRenewal(days: number = 30): Promise<PaginatedResponse<Contract>> {
    try {
      const contracts = await this.getContracts({ pageSize: 1000 });
      const now = new Date();
      const futureDate = new Date();
      futureDate.setDate(now.getDate() + days);

      const renewalContracts = contracts.data.filter(contract => {
        if (!contract.auto_renew || !contract.next_renewal_date) return false;
        const renewalDate = new Date(contract.next_renewal_date);
        return renewalDate >= now && renewalDate <= futureDate;
      });

      return {
        data: renewalContracts,
        total: renewalContracts.length,
        page: 1,
        pageSize: renewalContracts.length,
        totalPages: 1,
      };
    } catch (error) {
      this.handleError('Failed to fetch contracts due for renewal', error);
      throw error;
    }
  }

  /**
   * Update contract status with lifecycle management
   */
  async updateContractStatus(id: string, status: string): Promise<Contract> {
    try {
      const contract = await this.getContract(id);
      const newStatus = status as Contract['status'];

      // Validate status transition
      const validation = this.validateStatusTransition(contract.status, newStatus);
      if (!validation.isValid) {
        throw new Error(`Invalid status transition: ${validation.errors.join(', ')}`);
      }

      const updatedContract = await factoryContractService.updateContractStatus(id, status);

      // Log lifecycle event based on status
      const eventType = this.getLifecycleEventType(newStatus);
      await this.logLifecycleEvent(id, eventType, `Status changed to ${newStatus}`);

      // Handle status-specific business logic
      await this.handleStatusChange(updatedContract, contract.status, newStatus);

      return updatedContract;
    } catch (error) {
      this.handleError(`Failed to update contract status for ${id}`, error);
      throw error;
    }
  }

  /**
   * Approve contract
   */
  async approveContract(id: string, approvalData: { stage: string; comments?: string }): Promise<Contract> {
    try {
      const contract = await this.getContract(id);

      // Business rule: only pending approval contracts can be approved
      if (contract.status !== 'pending_approval') {
        throw new Error('Only contracts pending approval can be approved');
      }

      // Update approval history
      const approvalRecord = {
        id: Date.now().toString(),
        stage: approvalData.stage,
        approver: 'current_user', // Would get from auth context
        status: 'approved' as const,
        comments: approvalData.comments,
        timestamp: new Date().toISOString(),
      };

      const updatedContract = await this.updateContract(id, {
        approval_history: [...(contract.approval_history || []), approvalRecord],
        approval_stage: approvalData.stage,
      });

      // If final approval, activate the contract
      if (approvalData.stage === 'final_approval') {
        await this.updateContractStatus(id, 'active');
      }

      await this.logLifecycleEvent(id, 'approved', `Contract approved at ${approvalData.stage} stage`);

      return updatedContract;
    } catch (error) {
      this.handleError(`Failed to approve contract ${id}`, error);
      throw error;
    }
  }

  /**
   * Export contracts
   */
  async exportContracts(format: 'csv' | 'json' = 'csv'): Promise<string> {
    try {
      return await factoryContractService.exportContracts(format);
    } catch (error) {
      this.handleError('Failed to export contracts', error);
      throw error;
    }
  }

  /**
   * Validate contract data
   */
  async validateContractData(data: ContractFormData): Promise<ContractValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required fields
    if (!data.title?.trim()) errors.push('Title is required');
    if (!data.customer_id) errors.push('Customer is required');
    if (!data.type) errors.push('Contract type is required');
    if (!data.start_date) errors.push('Start date is required');
    if (!data.end_date) errors.push('End date is required');

    // Date validation
    if (data.start_date && data.end_date) {
      const startDate = new Date(data.start_date);
      const endDate = new Date(data.end_date);
      if (endDate <= startDate) {
        errors.push('End date must be after start date');
      }
    }

    // Value validation
    if (data.value !== undefined && data.value < 0) {
      errors.push('Contract value cannot be negative');
    }

    // Business rules
    if (data.auto_renew && !data.renewal_terms?.trim()) {
      warnings.push('Renewal terms recommended for auto-renewing contracts');
    }

    // Priority validation
    if (!['low', 'medium', 'high', 'urgent'].includes(data.priority)) {
      errors.push('Invalid priority level');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validate contract update
   */
  async validateContractUpdate(currentContract: Contract, updates: Partial<ContractFormData>): Promise<ContractValidationResult> {
    // For updates, we can be more lenient but still validate business rules
    const errors: string[] = [];
    const warnings: string[] = [];

    // Cannot change customer on active contracts
    if (updates.customer_id && currentContract.status === 'active' && updates.customer_id !== currentContract.customer_id) {
      errors.push('Cannot change customer on active contracts');
    }

    // Date validation for updates
    const startDate = updates.start_date ? new Date(updates.start_date) : new Date(currentContract.start_date);
    const endDate = updates.end_date ? new Date(updates.end_date) : new Date(currentContract.end_date);

    if (endDate <= startDate) {
      errors.push('End date must be after start date');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Prepare contract data with defaults and business logic
   */
  private prepareContractData(data: ContractFormData): ContractFormData {
    const now = new Date().toISOString();

    return {
      ...data,
      // Set default values
      priority: data.priority || 'medium',
      reminder_days: data.reminder_days || [30, 14, 7, 1],
      tags: data.tags || [],
      approval_history: [],
      parties: data.parties || [],

      // Business logic for dates
      next_reminder_date: this.calculateNextReminderDate(data.end_date, data.reminder_days || [30, 14, 7, 1]),

      // Auto-renewal logic
      next_renewal_date: data.auto_renew && data.renewal_period_months
        ? this.calculateNextRenewalDate(data.end_date, data.renewal_period_months)
        : undefined,
    };
  }

  /**
   * Prepare contract update data
   */
  private prepareContractUpdateData(updates: Partial<ContractFormData>): Partial<ContractFormData> {
    const updateData: Partial<ContractFormData> = { ...updates };

    // Recalculate reminder dates if end date changed
    if (updates.end_date && updates.reminder_days) {
      updateData.next_reminder_date = this.calculateNextReminderDate(updates.end_date, updates.reminder_days);
    }

    // Recalculate renewal dates if auto-renew settings changed
    if ((updates.end_date || updates.renewal_period_months || updates.auto_renew !== undefined) && updates.auto_renew !== false) {
      const endDate = updates.end_date || updateData.end_date;
      const renewalMonths = updates.renewal_period_months || updateData.renewal_period_months;
      if (endDate && renewalMonths) {
        updateData.next_renewal_date = this.calculateNextRenewalDate(endDate, renewalMonths);
      }
    }

    return updateData;
  }

  /**
   * Calculate enhanced statistics
   */
  private calculateEnhancedStats(contracts: Contract[]): Partial<ContractStats> {
    const stats: Partial<ContractStats> = {
      byType: {},
      byStatus: {},
      byPriority: {},
      expiringSoon: 0,
    };

    const now = new Date();
    const thirtyDaysFromNow = new Date();
    thirtyDaysFromNow.setDate(now.getDate() + 30);

    contracts.forEach(contract => {
      // Count by type
      stats.byType![contract.type] = (stats.byType![contract.type] || 0) + 1;

      // Count by status
      stats.byStatus![contract.status] = (stats.byStatus![contract.status] || 0) + 1;

      // Count by priority
      stats.byPriority![contract.priority] = (stats.byPriority![contract.priority] || 0) + 1;

      // Count expiring soon
      const endDate = new Date(contract.end_date);
      if (endDate >= now && endDate <= thirtyDaysFromNow) {
        stats.expiringSoon!++;
      }
    });

    return stats;
  }

  /**
   * Validate status transition
   */
  private validateStatusTransition(fromStatus: Contract['status'], toStatus: Contract['status']): ContractValidationResult {
    const errors: string[] = [];

    // Define valid transitions
    const validTransitions: Record<string, string[]> = {
      draft: ['pending_approval', 'terminated'],
      pending_approval: ['active', 'draft', 'terminated'],
      active: ['renewed', 'expired', 'terminated'],
      renewed: ['active', 'terminated'],
      expired: ['terminated'],
      terminated: [], // Terminal state
    };

    const allowedStatuses = validTransitions[fromStatus] || [];
    if (!allowedStatuses.includes(toStatus)) {
      errors.push(`Cannot transition from ${fromStatus} to ${toStatus}`);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings: [],
    };
  }

  /**
   * Handle status change business logic
   */
  private async handleStatusChange(contract: Contract, oldStatus: Contract['status'], newStatus: Contract['status']): Promise<void> {
    // Handle specific status changes
    switch (newStatus) {
      case 'active':
        // Send activation notifications
        await this.sendContractNotification(contract, 'activated');
        break;

      case 'expired':
        // Handle expiration logic
        await this.handleContractExpiration(contract);
        break;

      case 'terminated':
        // Handle termination logic
        await this.handleContractTermination(contract);
        break;
    }
  }

  /**
   * Get lifecycle event type from status
   */
  private getLifecycleEventType(status: Contract['status']): ContractLifecycleEvent['eventType'] {
    switch (status) {
      case 'active': return 'activated';
      case 'expired': return 'expired';
      case 'terminated': return 'terminated';
      case 'renewed': return 'renewed';
      default: return 'created';
    }
  }

  /**
   * Log lifecycle event
   */
  private async logLifecycleEvent(
    contractId: string,
    eventType: ContractLifecycleEvent['eventType'],
    notes?: string,
    userId?: string
  ): Promise<void> {
    // In a real implementation, this would save to a database
    console.log(`Contract ${contractId}: ${eventType} - ${notes || ''}`);
  }

  /**
   * Calculate next reminder date
   */
  private calculateNextReminderDate(endDate: string, reminderDays: number[]): string | undefined {
    if (!reminderDays.length) return undefined;

    const end = new Date(endDate);
    const now = new Date();

    // Find the next upcoming reminder
    for (const days of reminderDays.sort((a, b) => a - b)) {
      const reminderDate = new Date(end);
      reminderDate.setDate(end.getDate() - days);

      if (reminderDate > now) {
        return reminderDate.toISOString().split('T')[0];
      }
    }

    return undefined;
  }

  /**
   * Calculate next renewal date
   */
  private calculateNextRenewalDate(endDate: string, months: number): string {
    const end = new Date(endDate);
    end.setMonth(end.getMonth() + months);
    return end.toISOString().split('T')[0];
  }

  /**
   * Send contract notification
   */
  private async sendContractNotification(contract: Contract, event: string): Promise<void> {
    // In a real implementation, this would send emails/notifications
    console.log(`Notification sent for contract ${contract.id}: ${event}`);
  }

  /**
   * Handle contract expiration
   */
  private async handleContractExpiration(contract: Contract): Promise<void> {
    // Business logic for expired contracts
    await this.sendContractNotification(contract, 'expired');

    // Could trigger renewal workflows, notifications, etc.
  }

  /**
   * Handle contract termination
   */
  private async handleContractTermination(contract: Contract): Promise<void> {
    // Business logic for terminated contracts
    await this.sendContractNotification(contract, 'terminated');

    // Could archive documents, update related records, etc.
  }

  /**
   * Get contract analytics
   */
  async getContractAnalytics(contractId: string): Promise<ContractAnalyticsData> {
    try {
      const contract = await this.getContract(contractId);

      // Calculate basic metrics
      const startDate = new Date(contract.start_date);
      const endDate = new Date(contract.end_date);
      const duration = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));

      // Mock analytics data - in real implementation would calculate from historical data
      return {
        contractId,
        metrics: {
          duration,
          valueUtilization: 85, // Percentage of contract value utilized
          renewalRate: contract.auto_renew ? 95 : 0,
          complianceScore: 92,
        },
        trends: {
          value: [contract.value * 0.2, contract.value * 0.4, contract.value * 0.7, contract.value],
          duration: [30, 60, 90, duration],
          dates: [
            startDate.toISOString().split('T')[0],
            new Date(startDate.getTime() + duration * 24 * 60 * 60 * 1000 * 0.25).toISOString().split('T')[0],
            new Date(startDate.getTime() + duration * 24 * 60 * 60 * 1000 * 0.5).toISOString().split('T')[0],
            endDate.toISOString().split('T')[0],
          ],
        },
      };
    } catch (error) {
      this.handleError(`Failed to get analytics for contract ${contractId}`, error);
      throw error;
    }
  }

  /**
   * Bulk operations
   */
  async bulkUpdateContracts(ids: string[], updates: Partial<ContractFormData>): Promise<Contract[]> {
    try {
      // Validate bulk updates
      for (const id of ids) {
        const contract = await this.getContract(id);
        const validation = await this.validateContractUpdate(contract, updates);
        if (!validation.isValid) {
          throw new Error(`Validation failed for contract ${id}: ${validation.errors.join(', ')}`);
        }
      }

      return await factoryContractService.bulkUpdateContracts(ids, updates);
    } catch (error) {
      this.handleError('Failed to bulk update contracts', error);
      throw error;
    }
  }

  async bulkDeleteContracts(ids: string[]): Promise<void> {
    try {
      // Business rule: cannot bulk delete active contracts
      for (const id of ids) {
        const contract = await this.getContract(id);
        if (contract.status === 'active') {
          throw new Error(`Cannot delete active contract ${id}`);
        }
      }

      await factoryContractService.bulkDeleteContracts(ids);
    } catch (error) {
      this.handleError('Failed to bulk delete contracts', error);
      throw error;
    }
  }

  /**
   * Get contract types
   */
  async getContractTypes(): Promise<string[]> {
    return ['service_agreement', 'nda', 'purchase_order', 'employment', 'custom'];
  }

  /**
   * Get contract statuses
   */
  async getContractStatuses(): Promise<string[]> {
    return ['draft', 'pending_approval', 'active', 'renewed', 'expired', 'terminated'];
  }

  /**
   * Get contract priorities
   */
  async getContractPriorities(): Promise<string[]> {
    return ['low', 'medium', 'high', 'urgent'];
  }
}